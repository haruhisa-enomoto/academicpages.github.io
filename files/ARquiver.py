class TranslationQuiver:
    def __init__(self, vertices, arrows, tau):
        """
        This is a class of the AR quiver of tau-categories
        over an algebraically closed field.

        `vertices`: the tuple of vertices
        `arrows`: the tuple of arrows `a`,
        where each arrow `a` is a tuple of the form (source, target)
        with source, target in `vertices`.
        `tau`: a dictionary, e.g. tau[M] = N for M, N in `vertices`

        To represent an element of the free abelian group with basis `vertices`,
        we use a (sorted) list whose elements are in `vertices`.
        """
        self.vertices = vertices
        self.arrows = arrows
        self.tau = tau
        self.tau_inv = {v: k for k, v in tau.items()} # the dictionary of tau^{-1}

        # Check whether the constructed data is actually a translation quiver.
        # First check that tau is a partial injection
        tau_image = [tau[M] for M in tau]
        if len(tau_image) != len(set(tau_image)):
            raise ValueError("There's overlap of tau")
        # if there're overlap, then tau is not injective
        # Next check whether it satisfies the axiom of translation quiver
        for M in tau:
            tauM = tau[M]
            tauM_to_vtx = [arrow[1] for arrow in self.arrows if arrow[0] == tauM]

            # the list of vertices N s.t. there's arrow tauM -> N
            # (Multiple arrows are counted)
            from_M_vtx = [arrow[0] for arrow in self.arrows if arrow[1] == M]
            # the list of vertices N s.t. there's arrow N -> M
            tauM_to_vtx.sort()
            from_M_vtx.sort()
            if tauM_to_vtx != from_M_vtx:
                raise ValueError(f"{M} and its tau {tauM} doesn't satisfy the axiom!")

    def tau_plus(self, data):
        """
        `data`: a list of vertices (with multiplicity),
         which we regard as an element of the free abelian monoid generated by vertices.

        tau_plus is the sum of tau (zero if not defined).
        RETURN: tau_plus of `data` (represented by a list)
        """
        if data in self.vertices:
            data = [data]
        result = []
        for M in data:
            if M in self.tau:
                result.append(self.tau[M])
        return sorted(result)

    def tau_minus(self, data):
        """
        `data`: a list of vertices (with multiplicity),
         which we regard as an element of the free abelian monoid generated by vertices.

        tau_minus is the sum of tau^{-1} (zero if not defined).
        RETURN: tau_minus of `data` (represented by a list)
        """
        if data in self.vertices:
            data = [data]
        result = []
        for M in data:
            if M in self.tau_inv:
                result.append(self.tau_inv[M])
        return sorted(result)

    def theta_plus(self, data):
        """
        `data`: a list of vertices (with multiplicity),
         which we regard as an element of the free abelian monoid generated by vertices.

        theta of M is the sum of X s.t. there's arrow X -> M (with multiplicity)
        RETURN: theta of M (represented by a list).
        """

        if data in self.vertices:
            data = [data]
        result = []
        for M in data:
            result.extend([ar[0] for ar in self.arrows if ar[1] == M])
        return sorted(result)

    def theta_minus(self, data):
        """
        `data`: a list of vertices (with multiplicity),
         which we regard as an element of the free abelian monoid generated by vertices.

        theta_minus of M is the sum of X s.t. there's arrow M -> X (with multiplicity)
        RETURN: theta_minus of M (represented by a list).
        """

        if data in self.vertices:
            data = [data]
        result = []
        for M in data:
            result.extend([ar[1] for ar in self.arrows if ar[0] == M])
        return sorted(result)

    def _next_ladder_right(self, data):
        A, B = data
        """
        A hidden method, used only to calculate self.ladder_right().
        We have A -> B.
        This compute the next step:
        tau(B) -> (theta(B) - A)+.
        """
        result = self.theta_plus(B)
        # Compute the positive part of theta(B) - A.
        # For each element in A, just remove it from theta(B) if exists.
        for M in A:
            if M in self.theta_plus(B):
                result.remove(M)
        return (self.tau_plus(B), result)

    def _next_ladder_left(self, data):
        A, B = data
        """
        A hidden method, used only to calculate self.ladder_right().
        We have A -> B.
        This compute the next step:
        (theta_minus(A) - B)+ -> tau_minus(A).
        """

        result = self.theta_minus(A)
        # Next compute the positive part of theta_minus(A) - B.
        # For each element in B, just remove it from theta_minus(A) if exists.
        for M in B:
            if M in result:
                result.remove(M)
        return (result, self.tau_minus(A))

    def ladder_right(self, vertex):
        """
        Return the right ladder of (0 -> vertex).
        It's n-th term is tau(theta_{n-1}) (vertex) -> theta_n (vertex) in Iyama's notation
        Then (-,A) -> (-,B) -> J^n(-,vertex) -> 0 is a minimal projective presentation
        (hence gives the radical layers).

        This will stop if the computation doesn't stop after 1000 steps.

        RETURN: list [([],vertex), (A_1,B_1), ...] (one step before ([],[]) appears)
        """
        if vertex not in self.vertices:
            raise ValueError("This is not a vertex!")

        ladder = [([],[vertex])]
        current = ([],[vertex])
        for i in range(1001): # i = 0,..., 1000
            next = self._next_ladder_right(current)
            if next == ([],[]):
                break
            ladder.append(next)
            current = next
        if i == 1000:
            raise Warning("The computation of ladder doesn't terminate after 1000 steps, hence it seems that this category is not Hom-finite.")
        return ladder

    def ladder_left(self, vertex):
        """
        Return the right ladder of (vertex -> 0).
        If its n-th term is (A -> B), then
        Then (B,-) -> (A,-) -> J^n(vertex, -) -> 0 is a minimal projective presentation
        (hence gives the radical layers).

        This will stop if the computation doesn't stop after 1000 steps.

        RETURN: list [(vertex, []), (A_1,B_1), ...] (one step before ([],[]) appears)
        """
        if vertex not in self.vertices:
            raise ValueError("This is not a vertex!")

        ladder = [([vertex], [])]
        current = ([vertex], [])
        for i in range(1001): # i = 0,..., 1000
            next = self._next_ladder_left(current)
            if next == ([],[]):
                break
            ladder.append(next)
            current = next
        if i == 1000:
            raise Warning("The computation of ladder doesn't terminate after 1000 steps, hence it seems that this category is not Hom-finite.")
        return ladder

    def radical_layer(self, vertex, type = "contravariant"):
        if type == "contravariant":
            return [x[1] for x in self.ladder_right(vertex)]
        elif type == "covariant":
            return [x[0] for x in self.ladder_left(vertex)]

    def hom(self, X, Y):
        dim = 0
        for layer in self.radical_layer(Y):
            dim = dim + layer.count(X)

        dim2 = 0
        for layer in self.radical_layer(X, type = "covariant"):
            dim2 = dim2 + layer.count(Y)

        if dim != dim2:
            raise ValueError("Something wrong! Right and left computations don't coincide!")
        return dim
